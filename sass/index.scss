// maximum content width
// If you are going for a full fluid design, set this
// value to 100%.
$rr-maxwidth: 72rem !default;

// Divisions of the base grid size.
$rr-line-height: 1rem !default;

// How many grid squares will fit in the default line
// height. The larger this number is, the more options
// you have but the more difficult it becomes to establish
// a vertical rhythm.
$rr-grid-divisions: 2 !default;

// By default, the last breakpoint is set to `$rr-maxwidth`
// + `$rr-maxwidth-margin` to prevent a case where the
// max content width sits against left and right margins.// 
// If you are going for a full fluid design, set this value
// to 0.
$rr-maxwidth-margin: 4rem !default;

// Blend mode for the grid/columns overlay. This might not
// work on all browsers. (Looking at you, Edge.)
$rr-blend-mode: exclusion !default;

// Default responsive settings, assuming a mobile-first
// approach. The first breakpoint will be used as the 
// default settings outside of a media query. If you do
// not redefine a setting in a larger breakpoint it 
// will inherit from one of the smaller breakpoints,
// just as you would expect.

$rr-grid-settings: ( 
    s: ( 
        mq: max-width, 
        size: 35rem, 
        columns: 4, 
        gutter: 1rem / $rr-grid-divisions, 
        offset: 1rem, 
        vspace: 2,
        column_color: rgba(128, 128, 128, .5),
        baseline_color: rgba(128, 128, 128, .5)
    ), 
    m: ( 
        mq: min-width, 
        size: 35rem, 
        columns: 8, 
        offset: 2rem,
        vspace: 3
    ), 
    l: ( 
        size: 48rem, 
        columns: 12 
    ), 
    xl: ( 
        size: $rr_maxwidth + 4rem, 
        offset: 0,
        vspace: 4
    )
) !default;

// Gets the list of breakpoints; very useful for walking
// the configuration.
@function rr-breakpoint-list() {
    @return map-keys($rr-grid-settings);
}


// Compute the size of a grid square, computed in the unit of the
// line height. This is currently simple math but I've abstracted
// it out into a function in case we want to get more complicated
// later.
@function rr-gridbase() {
    @return $rr-line-height / $rr-grid-divisions;
}


// Turns a number of grid subdivisions ($steps) into a size expressed
// in the base grid units. For example, `rr-grid-units(1)` should 
// return `0.5rem` if `$rr-base-grid` is `1rem` and `$rr-grid-divisions`
// is `2`.
@function rr-grid-units($steps) {
    @return rr-gridbase() * $steps;
}

// Return a breakpoint configuration for the specified tag. 
// The tag is the first-level value in the `$rr-grid-settings` map.
// This does not compute mobile-first cascade; you need to 
// use `$rr-combined-breakpoint` instead. 
@function rr-breakpoint($tag) {
    $config: $rr-grid-settings;
    @if map-has-key($config, $tag) {
        @return map-get($config, $tag);
    }
    @else {
        @return map-get($config, nth(map-keys($config), 1));
    }
}

//Returns the first breakpoint config settings.
// Remember maps are 1-indexed.
@function rr-breakpoint-first() {
    @return rr-breakpoint(nth(rr-breakpoint-list(), 1));
}

// Return a breakpoint configuration for the specified tag. 
// The tag is the first-level value in the `$rr-grid-settings` map. 
// Unlike `rr-breakpoint`, this will look up values from earlier 
// breakpoints. 
@function rr-combined-breakpoint($break: s) {
    $breaks: rr-breakpoint-list();
    $work-map: rr-breakpoint-first();
    $stop: index($breaks, $break);
    @if not $stop {
        @return $work-map;
    } // Bounds-check the stop
    @if ($stop > 1) {
        @for $i from 2 through $stop {
            $tag: nth($breaks, $i);
            $work-map: map-merge($work-map, rr-breakpoint($tag));
        }
    }
    @return $work-map;
}

// Given a breakpoint tag and a property name, return the property value. 
// This looks for the property in the combined breakpoint.
@function rr-prop-for-breakpoint($break, $prop) {
    $bp: rr-combined-breakpoint($break);
    @if map-has-key($bp, $prop) {
        @return map-get($bp, $prop);
    }
    @return null;
}


// Given a breakpoint tag and a property name, return the property value. 
// This looks for the property only in the specified breakpoint.
@function strict-prop-for-breakpoint($break, $prop) {
    $bp: rr-breakpoint($break);
    @if map-has-key($bp, $prop) {
        @return map-get($bp, $prop);
    }
    @return null;
}

// Render the columns as a repeating linear gradient.
@function rr-columns($break: s) {
    $gutter: rr-prop-for-breakpoint($break, gutter);
    $color: rr-prop-for-breakpoint($break, column_color);
    $columns: rr-prop-for-breakpoint($break, columns);
    $colwidth: 100% / $columns;
    @if not $color {
        $color: rgba(0, 0, 0, .5);
    }
    @return repeating-linear-gradient( to left, transparent 0, transparent $gutter, $color $gutter, $color $colwidth);
}

// Render the baselines as a simple linear gradient. This gradient has 
// small enough values that Safari goes batshit if you try to do it with a 
// repeating linear gradient. 
@function rr-baselines($break: s) {
    $baseline: rr-gridbase();
    $color: rr-prop-for-breakpoint($break, baseline_color);
    @if not $color {
        $color: rgba(0, 0, 0, .5);
    }
    @return linear-gradient( to top, #{$color} 0, #{$color} 1px, transparent 1px, transparent 100%);
}
 
// Pass a fontsize and how many grid-spaces of spacing you want around it,
// and this will return font size and line-height declarations. Line-heights
// are sent back with a unit (instead of unitless) in an attempt to keep 
// the grid a little more bullet-proof. 
//
// If you want smaller line-height than the font size, you can pass negative 
// values.
//
// If you want a line height close to 1, make sure the font size is a multiple
// of the grid base and `$steps` is 0.
@mixin rr-font-line-height($fontsize, $steps: 0) {
    // Our grid unit
    $gridbase: rr-gridbase(); // Match to the font size
    $container: ceil($fontsize / $gridbase) * $gridbase; // Add the offset value to the text
    $leading: $steps * $gridbase;
    font-size: $fontsize;
    line-height: $container + $leading;
}

// Add columns to a ::before pseudoelement, gridlines to an ::after pseudoelement.
@mixin rr-grid-overlay {
    &::before {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        margin-right: auto;
        margin-left: auto;
        max-width: $rr_maxwidth;
        min-height: 100vh;
        z-index: 1000;
        pointer-events: none;
        mix-blend-mode: $rr-blend-mode;
        $breaks: rr-breakpoint_list();
        @each $break in $breaks {
            $offset: rr-prop-for-breakpoint($break, offset);
            $gutter: rr-prop-for-breakpoint($break, gutter);
            $cols: rr-prop-for-breakpoint($break, columns);
            @include rr-break-directive($break) {
                @if $offset>0 {
                    width: calc(100% - (2 * #{$offset}));
                }
                @else {
                    width: 100%;
                }
                background-image: rr-columns($break);
                background-size: calc(100% + #{$gutter});
            }
        }
    }
    &::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        margin-right: auto;
        margin-left: auto;
        min-height: 100vh;
        z-index: 1000;
        pointer-events: none;
        mix-blend-mode: $rr-blend-mode;
        $breaks: rr-breakpoint_list();
        @each $break in $breaks {
            @if $break == nth($breaks,1) {
                background: transparent rr-baselines($break) scroll repeat left top / 100% rr-gridbase();
            } 
            @else {
                @include rr-break-directive($break) {
                    background: transparent rr-baselines($break) scroll repeat left top / 100% rr-gridbase();
                }
            }
        }
    }
}

// Convenience mixin for building breakpoints around the media queries. 
@mixin rr-break-directive($break) {
    $mq: rr-prop-for-breakpoint($break, mq);
    $size: rr-prop-for-breakpoint($break, size);
    @media screen and ($mq: $size) {
        @content;
    }
}

@mixin rr-slab {
    $breaks: rr-breakpoint_list();

    @each $break in $breaks {
        $vspace: rr-grid-units(rr-prop-for-breakpoint($break, vspace));
        @if $break==nth($breaks, 1) {
            padding: $vspace rr-prop-for-breakpoint($break, offset);
        }
        @else {
            @include rr-break-directive($break) {
                padding: $vspace rr-prop-for-breakpoint($break, offset);
            }
        }
    }
}

@mixin rr-slab-wrapper() {
    max-width: $rr-maxwidth;
    margin: 0 auto;

    > :first-child {
        margin-top: 0;
    }

    > :last-child {
        margin-bottom: 0;
    }    
}

@mixin rr-slab-full-fullbleed {
    max-width: none;
}

@mixin rr-slab-adjacency($style-list) {
    @each $style in $style-list {
        .#{$style} + .#{$style} {
            padding-top: 0;
        }
    }
}